package es.iesjandula.reaktor.monitoring_client.windows;

import es.iesjandula.reaktor.models.Malware;
import es.iesjandula.reaktor.monitoring_client.utils.HttpCommunicationSender;
import es.iesjandula.reaktor.monitoring_client.utils.ListUtils;
import es.iesjandula.reaktor.monitoring_client.utils.exceptions.ConstantsErrors;
import es.iesjandula.reaktor.monitoring_client.utils.exceptions.ReaktorClientException;
import lombok.extern.slf4j.Slf4j;
import org.springframework.beans.factory.annotation.Autowired;
import org.springframework.beans.factory.annotation.Value;
import org.springframework.stereotype.Service;
import oshi.SystemInfo;
import oshi.software.os.OSDesktopWindow;
import oshi.software.os.OSProcess;
import oshi.software.os.windows.WindowsOperatingSystem;

import java.util.ArrayList;
import java.util.HashSet;
import java.util.List;


@Service
@Slf4j
public class WindowsMalware
{

    @Autowired
    private ListUtils listUtils;

    @Autowired
    private HttpCommunicationSender httpCommunicationSender;

    private List<Malware> malwareList;

    @Value("${reaktor.server.url}")
    private String reaktorServerUrl;

    public WindowsMalware()
    {
        this.malwareList = new ArrayList<>();
    }


    /**
     * This method returns a list of malware that are in the pc
     *
     * @return List<Malware> malwareListInThisPc
     */
    public List<Malware> getMalwareListInThisPc()
    {
        this.malwareList = this.getMalwareListFromServer();

        List<Malware> malwareListInThisPc = new ArrayList<>();

        List<OSProcess> processes = new SystemInfo().getOperatingSystem().getProcesses();

        List<OSDesktopWindow> windowList = new WindowsOperatingSystem().getDesktopWindows(false);

        processes = this.listUtils.removeDuplicates(processes);

        // Clean the motherboard list of the malware for only have the motherboards that have the malware

        for (OSProcess process : processes)
        {
            for (Malware malware : this.malwareList)
            {
                if (process.getName().toLowerCase().contains(malware.getName().toLowerCase()))
                {
                    malwareListInThisPc.add(malware);
                }
            }
        }

        for (OSDesktopWindow window : windowList)
        {
            for (Malware malware : this.malwareList)
            {
                if (window.getTitle().toLowerCase().contains(malware.getName().toLowerCase()))
                {
                    malwareListInThisPc.add(malware);
                }
            }
        }

        malwareListInThisPc = this.removeDuplicatedMalware(malwareListInThisPc);

        return malwareListInThisPc;
    }

    private List<Malware> removeDuplicatedMalware(List<Malware> malwareListInThisPc)
    {

        return new ArrayList<Malware>(new HashSet<>(malwareListInThisPc));

    }


    /**
     * This method returns a list of malware that are in the server
     *
     * @return List<Malware> malwareList
     */
    public List<Malware> getMalwareListFromServer()
    {
        List<Malware> malwareList = new ArrayList<>();
        try
        {
            malwareList = this.httpCommunicationSender.sendGetMalware(this.httpCommunicationSender.createHttpGetWithOutHeader(this.reaktorServerUrl + "/malware"));
        }
        catch (ReaktorClientException reaktorClientException)
        {
            log.warn(reaktorClientException.getMessage());
            log.warn(ConstantsErrors.ERROR_COMMUNICATION_TO_SERVER, reaktorClientException);
            reaktorClientException.printStackTrace();
        }
        return malwareList;
    }

}
